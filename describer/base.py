import importlib
import inspect
from pathlib import Path

NEW_DESCRIBER_FUNCTION_NAME = 'new_describer'

class ImageDescriber:
    """Image description interface.
    To ask questions about an image using a variety of models.

    Usage:

    # Instantiate a custom description class based on Moondream model
    describer = Describer.new('moondream')
    # Get the name of the model
    describer.get_name()
    # Ask a question about the image
    answer = describer.answer_question("myimage.jpg", "How many people in this image?")
    """

    @classmethod
    def new(cls, describer_name, model_id='', model_version=''):
        """Returns a new instance of a describer class
        found in module describer_name.
        Returns None if no match found.
        See other modules in this package."""
        ret = None

        if (Path(__file__).parent / Path(describer_name + '.py')).exists():
            module = importlib.import_module('describer.' + describer_name)
            for member_name in dir(module):
                member = getattr(module, member_name)
                if inspect.isclass(member) and issubclass(member, cls):
                    ret = member(model_id, model_version)

        return ret

    def __init__(self, model_id='', model_version=''):
        self.model = None
        self.model_id = model_id
        self.model_version = model_version

    def get_name(self) -> str:
        """Returns the name of the underlying model.
        In the hugging face format: org/model:version.
        E.g. vikhyatk/moondream2:2024-07-23.
        This can be looked up on HF website.
        """
        return f'{self.model_id}:{self.model_version}'

    def answer_question(self, image_path: str, question: str) -> str:
        """Returns a string generated by a multimodal model
        to answer a 'question' about an image in image_path.
        """
        raise Exception('Method should be implemented.')

    def answer_questions(self, image_path: str, questions: dict) -> dict:
        """Returns answers to all questions 
        about an image in image_path.
        """
        ret = {}
        for question_key, question in questions.items():
            self.log(f'question - before - {question_key}')
            ret[question_key] = self.answer_question(image_path, question)
            self.log(f'question - after - {question_key}')
        return ret

    def set_optimisation(self, optimise=False):
        self.optimise = optimise

    def set_timer(self, timer=None):
        self.timer = timer
    
    def log(self, message):
        timer = getattr(self, 'timer')
        if timer:
            timer.step(message)
    
    def log_fatal(self, message):
        message = f'ERROR: {message}'
        self.log(message)
        
        print(message)
        exit(1)

    def get_model(self):
        if not self.model:
            self._init_model()
        
        return self.model

    def _init_model(self):
        '''Returns a new transformer model instance.
        Based on self.model_id and self.model_version.
        Also sets it on self.model.
        '''
        raise Exception('Method should be implemented.')

    def get_compute_info(self):
        ret = {
            'type': 'cpu',
            'desc': 'cpu',
            'size': 0
        }

        model = self.get_model()

        if hasattr(model, 'parameters'):
            device = next(model.parameters()).device
            ret['type'] = device.type
            if device.type == 'cuda':
                import torch
                ret['desc'] = f'{device} = {torch.cuda.get_device_properties(device.index)}'
    
        return ret
